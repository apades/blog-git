{"meta":{"title":"apad station","subtitle":"restart","description":"仅仅一个刚接触前端的菜鸟","author":"apad","url":"https://apading.xyz","root":"/"},"pages":[{"title":"about","date":"2019-09-16T14:07:42.000Z","updated":"2019-09-16T14:08:04.462Z","comments":true,"path":"about/index.html","permalink":"https://apading.xyz/about/index.html","excerpt":"","text":"this is me!"},{"title":"categories","date":"2019-09-16T14:04:30.000Z","updated":"2019-09-16T14:07:03.879Z","comments":true,"path":"categories/index.html","permalink":"https://apading.xyz/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-16T13:59:03.000Z","updated":"2019-09-16T14:06:21.574Z","comments":true,"path":"tags/index.html","permalink":"https://apading.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一些前端的知识","slug":"面试用","date":"2019-11-22T00:14:42.917Z","updated":"2019-12-24T03:51:49.327Z","comments":true,"path":"posts/1/","link":"","permalink":"https://apading.xyz/posts/1/","excerpt":"","text":"计算机网络在浏览器中输入URL后执行的过程 DNS解析服务器IP地址 建立TCP连接 TCP详解 客户端发起HTTP请求 服务器收到请求，返回HTTP回复 浏览器解析HTML，并请求HTML代码中的资源 渲染过程 断开TCP连接 DNS （Domain Name System）用于TCP/IP网络，作用是将主机名和域名转化为IP地址 TCP/IP协议OSI模型 应用层 传输层 网络层 数据链路层 MAC地址 使用位置：数据链路层，转发数据帧 说明：物理地址，定义网络设备的位置，是唯一标识 IP地址 使用位置：网络层，保证通信正常 说明：互联网协议地址 HTTPURI (Uniform Resource Identifier)统一资源标识符，用于表示某个互联网资源 TCP:star: 三次握手 客户端发送 携带SYN标志位的包， 请求建立连接 服务器响应 携带SYN和ACK标志位的包，同意建立连接 客户端发送 携带ACK标志位的包， 表示连接成功 开始传输数据 四次挥手 客户端发送 携带FIN标志位的包， 请求断开连接 服务端响应 携带ACK标志位的包， 同意客户端断开连接 服务端发送 携带FIN标志位的包， 请求断开连接 客户端发送 携带ACK标志位的包， 同意服务端断开连接 常用的协议的端口号:star: 应用程序 FTP TFTP TELNET SMTP DNS HTTP SSH MYSQL 端口 21,20 69 23 25 53 80 22 3306 传输层协议 TCP UDP TCP TCP UDP TCP 浏览器浏览器内核 浏览器 IE Chrome FireFox 内核 IE内核 webkie Mozilla HTML渲染过程渲染模块 解释HTML解释器解释HTML，作用是将HTML文本解释成DOM树（文档对象模型） CSS解释器解释样式表的解释器，作用是将DOM中的各个元素对象加上样式信息 布局将DOM和CSS样式表信息结合起来，计算他们的大小位置等分布信息，形成一个能够表示所有信息的内部表示模型（渲染树） JavaScript引擎解析js 渲染过程:star: 解析HTML文件，创建DOM树 解析CSS，形成CSS对象模型 将CSS和DOM合并，构建渲染树 布局和绘制 渲染术语:star:重绘修改 不影响元素在网页中的位置和布局 的样式，例如background-color，visibility 重绘不会带来重新布局，所以并不一定伴随重排。 重排渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。 会触发重排的事件： 页面初次渲染 DOM操作（元素添加、删除、修改或顺序改变） 获取例如元素的offsetTop的值 元素本身尺寸发生变化，包括文本 浏览器窗口大小发生变化 重排必定带重绘 总结重绘重排的代价：耗时，导致浏览器卡慢，解决方案 WEB存储cookie 大小限制：4KB 信息组成： 名称 值 失效时间 （默认为浏览器关闭即清除） 路径 域名 安全标志 说明：每次http请求都会在头部添加cookie并发送 :star: 缺点： 大小受限 用户可操作，安全性低 浪费宽带 sessionStorage 大小限制：5MB 时间限制：浏览器关闭 说明：里面的数据只在相同协议、相同域名、相同端口下的页面之间共享 localStorage 大小限制：5MB 时间限制：无限直至删除 说明：就是个独立的存储数据在本地的功能 跨域是浏览器同源策略限制的原因，只有相同的协议名、主域名、子域名、端口号才可以放行 解决办法： jsonp 核心思想：利用script不受同源策略影响 使用方法：就是添加一个带有callback=name的query的script标签，然后声明name函数 其实就是服务器端返回一段name(jsonData)调用该函数 CORS 核心思想：服务端中在响应报文中添加属性，让浏览器放行 使用方法： Access-Control表示* 名字 说明 *-Allow-Credentials 服务端是否接受cookie *-Allow-Origin 指定哪些域名可以访问 *-Allow-Headers 表示服务器支持的请求数据类型 H5的window.postMessage 使用方式：两个iframe之间传输 性能优化最小化重绘和重排修改单个元素1234var div = document.querySelector('.div');div.style.width = '200px';div.style.background = 'red';div.style.height = '300px'; 以上会导致2次重排，3次重绘 最优解为 12var el = document.querySelector('.el');el.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px'; 修改多个元素步骤： 将多个元素的display设置为none 对元素进行操作 将多个元素的display设置回原本状态 总结一些要点:star: 直接改变元素的class 如需要类似offsetTop属性，先用一个变量存储他，否则每次使用都是一次重排 将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响到其他元素 JS一些名词 函数 函数声明 function a(){} 函数表达式 var a = function(){} 块级作用域 1234&#123; var a = 1&#125;clog(a) // 1 但要注意，js只有let声明变量才有块级作用域，var没有，但是可以用以下方法模拟块级作用域 1234(function()&#123; var a = 1&#125;)()clog(a) //ReferenceError 事件循环机制:star: JavaScript是一门单线程的非阻塞的脚本语言 如果js同时有两个线程，同时对同一个DOM进行操作，这时浏览器应该听哪个线程的，如何判断优先级？ 为了避免这种问题，js必须是一门单线程语言，并且在未来这个特点也不会改变。 宏任务 宏任务内可能包括微任务，宏任务队列需要微任务队列执行完才执行 I/O （例如鼠标事件、键盘事件） setTimeout setInterval requestAnimationFrame （canvas用的） 微任务 微任务队列需要等待js栈（主线程）运行完成 MutationObserver （DOM状态监视） Promise的then，catch和finally JS栈（主线程） js的解析和运行队列，js主线程运行时也算一个’script’任务 以下有一个嵌套DOM挂载点击事件，使用鼠标和js的差别的坑 link 简单来说： 鼠标点击时，会在宏任务微任务运行完后进行事件冒泡，开始添加新的宏任务和微任务 js运行点击事件时，该方法会阻塞js主线程，js栈的‘script’在没法结束下进行事件冒泡，微任务和宏任务会继续叠加直至冒泡结束和js栈为空 运行顺序 一些术语 js实现异步的方案 同步代码直接执行 异步函数放进异步队列 同步代码执行完毕，异步队列开始轮询 轮询 当一个异步函数执行完之后，再到异步队列监视。一直循环往复就叫时间轮询 js的栈和堆:star:原始类型保存在栈中，引用类型保存在堆中 一些图示栈 初始状态 var a = 11 var a = 11; var b = a var a = 11; var b = a; a =12 注意的是，原本a = 11 的11并没有被删除，除非不停地创建变量，直到栈满了，就会被删除掉 堆 var arr1 = [1,2] var arr1 = [1,2]; var arr2 = arr1 一些总结 在栈中，除非不停地创建变量，直到栈满了，就会被覆盖掉最旧的同名变量的内存 在堆中，如果一个堆不能间接或直接的被根对象(window或global)引用，就会被释放掉 Promise存在三种状态 pending rejected resolved pending只能到rejected或者resolved状态，不能互相转化 js继承父类： 123456function Person(name)&#123; this.name = name this.getName = function()&#123; return this.name &#125;&#125; 原型链继承 1234function p1()&#123; this.name = 'p1'&#125;p1.prototype = new Person() 借用构造函数继承 123function p2()&#123; Person.call(this,'p2')&#125; 组合继承 1234function p3()&#123; Person.call(this,'p3')&#125;p3.prototype = new Person() 实现new的方法原理先看一段实际function相关的图 function对象 new一个对象 function对象原型改变 由此可以得出，new操作符是创建一个空对象，他的__proto__指向创建函数的prototype 实现123456function newObject(fn,...args)&#123; let obj = &#123;&#125; obj.__proto__ = fn.prototype fn.apply(obj,args) return obj&#125; 原型和原型链 原型 每一个对象都包含一个原型对象（除了null，undefined等少数对象），用于关联另一个对象，关联后就可以使用那个对象的属性和方法 原型链 对象之间通过原型关联到一起，如同一条锁链，当读取对象的一个属性或者方法时，会顺着这条链向原型链顶的方向查找，只有查找到或者到顶才会停止 作用域和作用域链只有函数和es6的let才有作用域 作用域 定义变量所处的位置，并限定变量可用的范围 如全局window下var a = 1和function a(){var a = 1} 作用域链 每个函数都有自己的作用域，一个函数还能嵌套一个函数，相当于作用域互相关联，查找方式如同原型链 闭包特点可以访问和操作另一个函数作用域中的变量 缺点 空间浪费 内存泄漏 性能消耗 跟堆的释放内存一样 12345678910function a()&#123; let num = 0 return function()&#123; return num ++ &#125;&#125;var a1 = a()a1() //0a1() //1a1 = null // 即可释放内存 CSS术语外边距塌陷指两个块级元素上下margin组合在一起 其中 两个都是正，取最大 两个都是负，取绝对值最大 一正一负，取两值相加 可以使用BFC消除塌陷 BFC (Block Formatting Context) 作用： 隔离，内部元素不会受外部元素的影响 BFC中的内容不会与外面的浮动元素重叠 计算BFC的高度包括了BFC内的浮动子元素的高度 创建方式：（满足以下的一个条件） 根元素（html） float不为none position是absolute或fixed display为 inline-block table-cell table-caption 伸缩盒（flex和inline-flex） overflow不为visible 选择器 基本选择器 名字 例子 通配 * 类型 div 类 .class ID #id 属性 [alt=”aaa”] 关系选择器 名字 例子 后代 .a1 .a2 子 .a1&gt;.a2 相邻 .a1+.a2 兄弟 .a1~.a2 HTMLH5新特性 语义化的WEB （就是标签article、ul-li这种） 削弱对第三发插件的依赖 增加多种应用和api，如 canvas 扩展js api，如web存储、地理位置、拖放、操作历史浏览记录等 离线web程序 添加语义元素，如article，header，更有利于爬虫爬取数据","categories":[],"tags":[]},{"title":"vuex快速学习笔记","slug":"vuex快速学习笔记","date":"2019-10-13T16:00:00.000Z","updated":"2019-10-24T05:13:02.084Z","comments":true,"path":"posts/49904/","link":"","permalink":"https://apading.xyz/posts/49904/","excerpt":"首先，需要考虑为什么上vuex 这也是我在开发过程中遇到的一个小问题，如果类似下面有多个组件嵌套的话用props和:data=&quot;data&quot;会显得太繁琐 而且根据官方文档说的props的数据是单向的，想要改变数据使用$emit(&#39;xxx&#39;)也很麻烦","text":"首先，需要考虑为什么上vuex 这也是我在开发过程中遇到的一个小问题，如果类似下面有多个组件嵌套的话用props和:data=&quot;data&quot;会显得太繁琐 而且根据官方文档说的props的数据是单向的，想要改变数据使用$emit(&#39;xxx&#39;)也很麻烦 demo目录结构 前提准备 vuex安装肯定的吧 store.js123456789101112131415161718192021222324252627282930313233343536import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)var store = new Vuex.Store(&#123; state:&#123; // 类似于xxx.vue的data() data: 'this is test' &#125;, getters:&#123; // 类似于xxx.vue的filters fdata(state)&#123; return state.data.toUpperCase() &#125; &#125;, mutations:&#123; // 类似于xxx.vue的methods change(state)&#123; state.data = 'change' &#125;, // 作为方法接受参数 replaceStr(state,str)&#123; state.data = str &#125; &#125;, actions:&#123; // 需要和mutations配套使用 // 根据官方文档，这个是**可以异步的** // mutations只支持**同步** test(context)&#123; context.commit('change')// 仅保留实例，实际上自己没有怎么用 &#125; &#125;&#125;)export default store main.js1234567891011import Vue from 'vue'import App from './App.vue'// 引入store.jsimport store from './store'Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App), store&#125;).$mount('#app') 最简单的用法App.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;app.vue&lt;/h1&gt; &lt;p&gt;state: &#123;&#123;$store.state.data&#125;&#125;&lt;/p&gt; &lt;p&gt;getters: &#123;&#123;$store.getters.fdata&#125;&#125;&lt;/p&gt; &lt;div&gt; &lt;p&gt;mutations:&lt;/p&gt; &lt;button @click=\"$store.commit('change')\"&gt;change&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;mutations:方法&lt;/p&gt; &lt;button @click=\"$store.commit('replaceStr','hahahah')\"&gt;change&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;actions&lt;/p&gt; &lt;button @click=\"$store.dispatch('test')\"&gt;change&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app'&#125;&lt;/script&gt; 结果 初始 点击mutations 点击mutations:方法 点击actions 也可以在export default的methods等处里使用this.$store调用 进阶用法 实际上上面的简单用法是最笨和最麻烦的 App.vue1234567891011121314151617181920212223&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;app.vue&lt;/h1&gt; &lt;p&gt;state: &#123;&#123;data&#125;&#125;&lt;/p&gt; &lt;comp-a/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex'import compA from './components/compA'export default &#123; name: 'app', computed:mapState(&#123; data:'data' &#125;), components:&#123; compA &#125;&#125;&lt;/script&gt; compA.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=\"comp-a\"&gt; &lt;h2&gt;comp-a&lt;/h2&gt; &lt;p&gt;state: &#123;&#123;data&#125;&#125;&lt;/p&gt; &lt;button @click=\"change\"&gt;change&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState,mapMutations&#125; from 'vuex'export default &#123; computed:mapState(&#123; data:'data' &#125;), methods:mapMutations(&#123; change: 'change' &#125;)&#125;;&lt;/script&gt;&lt;style&gt;.comp-a&#123; border: 1px solid black;&#125;&lt;/style&gt; 关于{mapState,mapMutations} 结果 初始 点击change 一些解释关于{mapState,mapMutations} 这个是对store里的state和mutations转化为自己的方法或值 例如mapState的获取state有以下三种 1234567891011121314151617import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 data: state =&gt; state.data, // 传字符串参数 'count' 等同于 `state =&gt; state.count` data: 'data', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.data + this.data &#125; &#125;)&#125; 但是自己最常用的还是 1computed: mapState(['data','example2']) 即使computed含有多个 1234computed: &#123; ...mapState(['data','example2']), dd: ()=&gt; 'dd'&#125; 关于...操作符这是es6的解构符号，类似于{}，使用方法很简单，以下用chrome的DevTools直接展开 数据解构 对象解构 结论vuex作为一个管理全局数据和状态真的很方便，比起$emit和:data=&quot;data&quot;这种方便多了","categories":[],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://apading.xyz/tags/vuex/"}]},{"title":"test","slug":"test","date":"2019-10-10T16:00:00.000Z","updated":"2019-11-01T08:54:26.998Z","comments":true,"path":"posts/63534/","link":"","permalink":"https://apading.xyz/posts/63534/","excerpt":"test","text":"test load asdasdasd bgImage('/assets/img/背景.jpg')","categories":[],"tags":[]},{"title":"gulp4.0使用gulp-connect插件","slug":"gulp4.0","date":"2019-09-30T16:00:00.000Z","updated":"2019-10-24T05:13:02.082Z","comments":true,"path":"posts/41474/","link":"","permalink":"https://apading.xyz/posts/41474/","excerpt":"前言虽然网上有许多类似的gulp3.0的task和series配套用法：gulp.task(&#39;server&#39;, gulp.series(&#39;connect&#39;, &#39;watch&#39;))但还是莫名其妙没触发更新","text":"前言虽然网上有许多类似的gulp3.0的task和series配套用法：gulp.task(&#39;server&#39;, gulp.series(&#39;connect&#39;, &#39;watch&#39;))但还是莫名其妙没触发更新 开始123456789101112131415161718var &#123; watch,src,dest &#125; = require('gulp'), connect = require('gulp-connect') function html() &#123; return src('src/*.html') .pipe(dest('dist')) .pipe(connect.reload())&#125;function server() &#123; connect.server(&#123; root: 'dist', livereload: true, index: 'index.html' &#125;)&#125;watch('src/*.html',html) // 这里虽然尝试过在default里用series作为一个函数，但还是没触发更新exports.default = server 结语虽然也是第一次上手gulp，之前用过webpack体验下来感觉一个几kb的文件越打包越大了，还是喜欢更直观一点的","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://apading.xyz/tags/gulp/"}]},{"title":"简单实现vue-cli下的动态组件","slug":"vue select comp","date":"2019-09-24T16:00:00.000Z","updated":"2019-10-24T05:13:02.083Z","comments":true,"path":"posts/24764/","link":"","permalink":"https://apading.xyz/posts/24764/","excerpt":"前言这只是开发中简单实现的，可能会繁琐，待改进中","text":"前言这只是开发中简单实现的，可能会繁琐，待改进中 数据data.js 123456789101112131415161718192021222324252627282930313233export default &#123; \"avatar\": &#123; \"headIconURL\": \"\", \"name\":\"APAD\", \"description\": \"\", \"skills\": [] &#125;, \"contact\":&#123; \"phone\":9999, \"email\":\"0000@qq.com\" &#125;, \"education\": &#123; \"school\": \"家里蹲大学\", \"specialty\": \"\", \"education_background\": \"本科\", \"time_from\": 2016, \"time_to\": 2020 &#125;, \"project\": [ &#123; \"name\": \"\", \"haveJobExperience\": false, \"description\": \"\", \"achievement\": \"\", \"time_from\": \"2019-8\", \"time_to\": \"2019-8\", \"link\": \"\" &#125; ], \"socialPage\": [ &#123;\"name\":\"\",\"URL\":\"\"&#125; ]&#125; main.js 1234567import Vue from 'vue'import store from './store'Vue.prototype.store = storenew Vue(&#123; render: h =&gt; h(App),&#125;).$mount('#app') 组件 例出两个组件 avatar.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;section&gt; &lt;div class=\"avatar\"&gt; &lt;!-- 头像 --&gt; &lt;img :src=\"data.avatar.headIconURL || 'https://iconfont.alicdn.com/t/1510710350863.png@100h_100w.jpg'\" alt=\"头像\" /&gt; &lt;!-- 名字 --&gt; &lt;h2&gt;&#123;&#123;data.avatar.name&#125;&#125;&lt;/h2&gt; &lt;!-- 学校/学历 --&gt; &lt;p&gt;&#123;&#123;data.education.school&#125;&#125; / &#123;&#123;data.education.education_background&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; data: this.store.data &#125;; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; education.vue 1234567891011121314151617181920212223242526&lt;template&gt; &lt;section&gt; &lt;div class=\"education\"&gt; &lt;h2&gt;教育经历&lt;/h2&gt; &lt;!-- 学校 --&gt; &lt;p&gt;&#123;&#123;data.education.school&#125;&#125;&lt;/p&gt; &lt;!-- 学历 | 专业 --&gt; &lt;p&gt;&#123;&#123;data.education.education_background&#125;&#125; | &#123;&#123;data.education.specialty&#125;&#125;&lt;/p&gt; &lt;!-- 时间 --&gt; &lt;p&gt;&#123;&#123;data.education.time_from&#125;&#125; - &#123;&#123;data.education.time_to&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; data: this.store.data &#125;; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 整合随便叫什么的.vue 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;button @click=\"changeContext\"&gt;change&lt;/button&gt; &lt;component :is=\"currentTab\"&gt; &lt;/component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import avatar from './avatar'import education from './education'export default &#123; data() &#123; return &#123; currentTab: 'avatar' // 这里的'avatar'可以是字符串也可以是import的avatar &#125;; &#125;, methods: &#123; changeContext(e) &#123; // 用来测试的 this.currentTab = 'education' &#125; &#125;, components:&#123; // 这里导入组件是必要的 avatar, education &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 运行 默认下 点击change后","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://apading.xyz/tags/vue/"}]},{"title":"Hello World (again)","slug":"Hello-World-(again)","date":"2019-09-13T16:00:00.000Z","updated":"2019-10-24T05:13:02.078Z","comments":true,"path":"posts/50469/","link":"","permalink":"https://apading.xyz/posts/50469/","excerpt":"还记得几个月前也下过hexo，一样用的yilia，但可惜的是腾讯服务器当时没法继续白嫖学生价服务器，也懒得拿出仅写的几篇废话博文了，仅此作怀念吧","text":"还记得几个月前也下过hexo，一样用的yilia，但可惜的是腾讯服务器当时没法继续白嫖学生价服务器，也懒得拿出仅写的几篇废话博文了，仅此作怀念吧 当时也是因为一下子接触了太多的东西，markdown、yaml、node、git…这些当时也是看到一篇博客的脚注才有得知这种博客模板的生成工具typecho，虽然隐约也听说过wordpress这种搭博客的工具，也使用过，不过说实话用着还挺懵逼的。 因为当时只是大致看完了w3cschool和runnooob的html和css教程，js只是停留在了会用jq操作dom，以为就很厉害了，结果一下了typecho当时竟然还不知道怎么安装，现在感觉也是好蠢啊。 一直以为的前端就是html，css和js，没想到要学的东西这么多，http协议、es6例如promise、浏览器渲染过程，甚至用的vue还要学服务器端的node（虽然到现在也没动力学vue-cli了，感觉用不来。。。 不过到现在还是感觉自己太倔了，好多东西都是刨根问底的去实现或者不想用，连wordpress这种只需要鼠标点点打个字就生成了新的博文也不想要，原先用的yilia主题也是因为没接触过node的运作原理对着源文件的文件修改样式发现没改变就骂辣鸡就不用了，甚至github也只是单纯的用clone搞几个看得懂的文章而已，demo也没下几个试过。这不过是以前搞css或者dom操作遗留下来的习惯，不过这么说下来，应该说是倔还是单纯的蠢呢，还是用工具舒服啊。 不过到现在为止，自学前端应该有1年多了吧，自从大二下学期开始课堂要求组队弄一个系统，就开始自学前端了，其实当时还是挺快乐的，一个晚上就看完了图书馆借的html教程的书，虽然现在想起来那些内容都挺久的还用着许多现在都不常见的标签，当时能实现出效果那瞬间还是忘不了。但是现在已经是大四开头了，大三也就相当于用着大二的作业混过去，一直都没怎么进步过，是时候重新开始了。。。 只不过这个时间不知道允不允许啊。。。感觉自己还是很菜，实习都没找到","categories":[],"tags":[]},{"title":"解决nodejs的Connection lost ：The server closed the connection","slug":"node mysql lost","date":"2019-09-12T16:00:00.000Z","updated":"2019-10-24T05:13:02.083Z","comments":true,"path":"posts/26878/","link":"","permalink":"https://apading.xyz/posts/26878/","excerpt":"前言这是由于mysql自带的一段时间无动作会自动关闭的机制","text":"前言这是由于mysql自带的一段时间无动作会自动关闭的机制 解决 使用闭包可以完美解决问题 123456789101112131415161718192021222324var mysql = require('mysql')var sqlConfig = &#123; host: 'localhost', user: 'root', password: 'pwd', database: 'dbbase'&#125;var conn = function()&#123; let connection = mysql.createConnection(sqlConfig) connection.connect() connection.on('error',err=&gt;&#123; console.log('Re-connecting lost connection: '); connection = mysql.createConnection(sqlConfig) &#125;) return function()&#123; return connection &#125;&#125;module.exports = conn()","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://apading.xyz/tags/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"https://apading.xyz/tags/mysql/"}]},{"title":"nodejs中用multer和express实现简单文件上传功能","slug":"multer express","date":"2019-08-25T16:00:00.000Z","updated":"2019-10-24T05:13:02.081Z","comments":true,"path":"posts/9500/","link":"","permalink":"https://apading.xyz/posts/9500/","excerpt":"前言鉴于官方文档有些地方没说清除自己去研究出来的","text":"前言鉴于官方文档有些地方没说清除自己去研究出来的 前提准备 express multer开始前端部分html12&lt;input type=\"file\" id=\"file\"/&gt;&lt;div id=\"submit\"&gt;submit&lt;/div&gt; js原生 因为jq的ajax用起来不习惯自己写了个 12345678910111213141516171819202122232425document.getElementById(\"submit\").addEventListener('click',upload)function upload()&#123; let file = document.getElementById(\"file\").files[0] postFile('http://localhost:3000/img',file,d=&gt;&#123; console.log('post ok'); console.log(d); &#125;)&#125;//ajax的方法function postFile(url,file,callback)&#123; let data = new FormData(), xhr = new XMLHttpRequest() data.append('file',file)//[1] xhr.open('POST',url,true) xhr.onload = function()&#123; if(callback) callback(xhr.responseText) &#125; xhr.send(data)&#125; 注意js中标记[1]的位置，后面有用到 jq 其实也差不多 123456789101112131415function upload()&#123; var data = new FormData() data.append('file',document.getElementById(\"image\").files[0]) $.ajax(&#123; url: 'http://localhost:3000/img', type: 'POST', data: data, // 下面两个是request的格式相关的，去掉会jq报错 contentType: false, processData: false, success(d)&#123; console.log(d); &#125; &#125;)&#125; 后端部分server-config.js 这是用来配置跨域的 1234567891011121314var express = require('express')var app = express()//跨域app.all('*',(req,res,next)=&gt;&#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next();&#125;)module.exports = app server.js1234567891011121314151617var multer = require('multer')var app = require('./server-config')// 文件上传测试var upload = multer(&#123; dest: 'uploads/' //这是存放文件的位置&#125;)//[2]app.post('/img', upload.single('file'), (req, res, next) =&gt; &#123; var img = req.file.path console.log(img); res.send(&#123; type: 'ok' &#125;)&#125;)app.listen(3000, () =&gt; console.log('server running')) 前面的[1]中的 append(&#39;name&#39;,文件)对应着[2]中的upload.single(&#39;name&#39;) 结束存在./uploads/里的文件是用随机码构成的，且没有后缀名","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://apading.xyz/tags/nodejs/"},{"name":"multer","slug":"multer","permalink":"https://apading.xyz/tags/multer/"}]}]}